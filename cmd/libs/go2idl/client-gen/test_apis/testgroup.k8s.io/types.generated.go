/*
Copyright 2016 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// ************************************************************
// DO NOT EDIT.
// THIS FILE IS AUTO-GENERATED BY codecgen.
// ************************************************************

package testgroup

import (
	"errors"
	"fmt"
	codec1978 "github.com/ugorji/go/codec"
	pkg2_api "k8s.io/kubernetes/pkg/api"
	pkg1_unversioned "k8s.io/kubernetes/pkg/api/unversioned"
	pkg3_types "k8s.io/kubernetes/pkg/types"
	"reflect"
	"runtime"
	time "time"
)

const (
	// ----- content types ----
	codecSelferC_UTF81234 = 1
	codecSelferC_RAW1234  = 0
	// ----- value types used ----
	codecSelferValueTypeArray1234 = 10
	codecSelferValueTypeMap1234   = 9
	// ----- containerStateValues ----
	codecSelfer_containerMapKey1234    = 2
	codecSelfer_containerMapValue1234  = 3
	codecSelfer_containerMapEnd1234    = 4
	codecSelfer_containerArrayElem1234 = 6
	codecSelfer_containerArrayEnd1234  = 7
)

var (
	codecSelferBitsize1234                         = uint8(reflect.TypeOf(uint(0)).Bits())
	codecSelferOnlyMapOrArrayEncodeToStructErr1234 = errors.New(`only encoded map or array can be decoded into a struct`)
)

type codecSelfer1234 struct{}

func init() {
	if codec1978.GenVersion != 5 {
		_, file, _, _ := runtime.Caller(0)
		err := fmt.Errorf("codecgen version mismatch: current: %v, need %v. Re-generate file: %v",
			5, codec1978.GenVersion, file)
		panic(err)
	}
	if false { // reference the types, but skip this branch at build/run time
		var v0 pkg2_api.ObjectMeta
		var v1 pkg1_unversioned.TypeMeta
		var v2 pkg3_types.UID
		var v3 time.Time
		_, _, _, _ = v0, v1, v2, v3
	}
}

func (x *TestType) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yym1 := z.EncBinary()
		_ = yym1
		if false {
		} else if z.HasExtensions() && z.EncExt(x) {
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			var yyq2 [4]bool
			_, _, _ = yysep2, yyq2, yy2arr2
			const yyr2 bool = false
			yyq2[0] = x.Kind != ""
			yyq2[1] = x.APIVersion != ""
			yyq2[2] = true
			yyq2[3] = true
			var yynn2 int
			if yyr2 || yy2arr2 {
				r.EncodeArrayStart(4)
			} else {
				yynn2 = 0
				for _, b := range yyq2 {
					if b {
						yynn2++
					}
				}
				r.EncodeMapStart(yynn2)
				yynn2 = 0
			}
			if yyr2 || yy2arr2 {
				z.EncSendContainerState(codecSelfer_containerArrayElem1234)
				if yyq2[0] {
					yym4 := z.EncBinary()
					_ = yym4
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.Kind))
					}
				} else {
					r.EncodeString(codecSelferC_UTF81234, "")
				}
			} else {
				if yyq2[0] {
					z.EncSendContainerState(codecSelfer_containerMapKey1234)
					r.EncodeString(codecSelferC_UTF81234, string("kind"))
					z.EncSendContainerState(codecSelfer_containerMapValue1234)
					yym5 := z.EncBinary()
					_ = yym5
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.Kind))
					}
				}
			}
			if yyr2 || yy2arr2 {
				z.EncSendContainerState(codecSelfer_containerArrayElem1234)
				if yyq2[1] {
					yym7 := z.EncBinary()
					_ = yym7
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.APIVersion))
					}
				} else {
					r.EncodeString(codecSelferC_UTF81234, "")
				}
			} else {
				if yyq2[1] {
					z.EncSendContainerState(codecSelfer_containerMapKey1234)
					r.EncodeString(codecSelferC_UTF81234, string("apiVersion"))
					z.EncSendContainerState(codecSelfer_containerMapValue1234)
					yym8 := z.EncBinary()
					_ = yym8
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.APIVersion))
					}
				}
			}
			if yyr2 || yy2arr2 {
				z.EncSendContainerState(codecSelfer_containerArrayElem1234)
				if yyq2[2] {
					yy10 := &x.ObjectMeta
					yym11 := z.EncBinary()
					_ = yym11
					if false {
					} else if z.HasExtensions() && z.EncExt(yy10) {
					} else {
						z.EncFallback(yy10)
					}
				} else {
					r.EncodeNil()
				}
			} else {
				if yyq2[2] {
					z.EncSendContainerState(codecSelfer_containerMapKey1234)
					r.EncodeString(codecSelferC_UTF81234, string("metadata"))
					z.EncSendContainerState(codecSelfer_containerMapValue1234)
					yy12 := &x.ObjectMeta
					yym13 := z.EncBinary()
					_ = yym13
					if false {
					} else if z.HasExtensions() && z.EncExt(yy12) {
					} else {
						z.EncFallback(yy12)
					}
				}
			}
			if yyr2 || yy2arr2 {
				z.EncSendContainerState(codecSelfer_containerArrayElem1234)
				if yyq2[3] {
					yy15 := &x.Status
					yy15.CodecEncodeSelf(e)
				} else {
					r.EncodeNil()
				}
			} else {
				if yyq2[3] {
					z.EncSendContainerState(codecSelfer_containerMapKey1234)
					r.EncodeString(codecSelferC_UTF81234, string("status"))
					z.EncSendContainerState(codecSelfer_containerMapValue1234)
					yy16 := &x.Status
					yy16.CodecEncodeSelf(e)
				}
			}
			if yyr2 || yy2arr2 {
				z.EncSendContainerState(codecSelfer_containerArrayEnd1234)
			} else {
				z.EncSendContainerState(codecSelfer_containerMapEnd1234)
			}
		}
	}
}

func (x *TestType) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yym17 := z.DecBinary()
	_ = yym17
	if false {
	} else if z.HasExtensions() && z.DecExt(x) {
	} else {
		yyct18 := r.ContainerType()
		if yyct18 == codecSelferValueTypeMap1234 {
			yyl18 := r.ReadMapStart()
			if yyl18 == 0 {
				z.DecSendContainerState(codecSelfer_containerMapEnd1234)
			} else {
				x.codecDecodeSelfFromMap(yyl18, d)
			}
		} else if yyct18 == codecSelferValueTypeArray1234 {
			yyl18 := r.ReadArrayStart()
			if yyl18 == 0 {
				z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
			} else {
				x.codecDecodeSelfFromArray(yyl18, d)
			}
		} else {
			panic(codecSelferOnlyMapOrArrayEncodeToStructErr1234)
		}
	}
}

func (x *TestType) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yys19Slc = z.DecScratchBuffer() // default slice to decode into
	_ = yys19Slc
	var yyhl19 bool = l >= 0
	for yyj19 := 0; ; yyj19++ {
		if yyhl19 {
			if yyj19 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecSendContainerState(codecSelfer_containerMapKey1234)
		yys19Slc = r.DecodeBytes(yys19Slc, true, true)
		yys19 := string(yys19Slc)
		z.DecSendContainerState(codecSelfer_containerMapValue1234)
		switch yys19 {
		case "kind":
			if r.TryDecodeAsNil() {
				x.Kind = ""
			} else {
				x.Kind = string(r.DecodeString())
			}
		case "apiVersion":
			if r.TryDecodeAsNil() {
				x.APIVersion = ""
			} else {
				x.APIVersion = string(r.DecodeString())
			}
		case "metadata":
			if r.TryDecodeAsNil() {
				x.ObjectMeta = pkg2_api.ObjectMeta{}
			} else {
				yyv22 := &x.ObjectMeta
				yym23 := z.DecBinary()
				_ = yym23
				if false {
				} else if z.HasExtensions() && z.DecExt(yyv22) {
				} else {
					z.DecFallback(yyv22, false)
				}
			}
		case "status":
			if r.TryDecodeAsNil() {
				x.Status = TestTypeStatus{}
			} else {
				yyv24 := &x.Status
				yyv24.CodecDecodeSelf(d)
			}
		default:
			z.DecStructFieldNotFound(-1, yys19)
		} // end switch yys19
	} // end for yyj19
	z.DecSendContainerState(codecSelfer_containerMapEnd1234)
}

func (x *TestType) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj25 int
	var yyb25 bool
	var yyhl25 bool = l >= 0
	yyj25++
	if yyhl25 {
		yyb25 = yyj25 > l
	} else {
		yyb25 = r.CheckBreak()
	}
	if yyb25 {
		z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
		return
	}
	z.DecSendContainerState(codecSelfer_containerArrayElem1234)
	if r.TryDecodeAsNil() {
		x.Kind = ""
	} else {
		x.Kind = string(r.DecodeString())
	}
	yyj25++
	if yyhl25 {
		yyb25 = yyj25 > l
	} else {
		yyb25 = r.CheckBreak()
	}
	if yyb25 {
		z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
		return
	}
	z.DecSendContainerState(codecSelfer_containerArrayElem1234)
	if r.TryDecodeAsNil() {
		x.APIVersion = ""
	} else {
		x.APIVersion = string(r.DecodeString())
	}
	yyj25++
	if yyhl25 {
		yyb25 = yyj25 > l
	} else {
		yyb25 = r.CheckBreak()
	}
	if yyb25 {
		z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
		return
	}
	z.DecSendContainerState(codecSelfer_containerArrayElem1234)
	if r.TryDecodeAsNil() {
		x.ObjectMeta = pkg2_api.ObjectMeta{}
	} else {
		yyv28 := &x.ObjectMeta
		yym29 := z.DecBinary()
		_ = yym29
		if false {
		} else if z.HasExtensions() && z.DecExt(yyv28) {
		} else {
			z.DecFallback(yyv28, false)
		}
	}
	yyj25++
	if yyhl25 {
		yyb25 = yyj25 > l
	} else {
		yyb25 = r.CheckBreak()
	}
	if yyb25 {
		z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
		return
	}
	z.DecSendContainerState(codecSelfer_containerArrayElem1234)
	if r.TryDecodeAsNil() {
		x.Status = TestTypeStatus{}
	} else {
		yyv30 := &x.Status
		yyv30.CodecDecodeSelf(d)
	}
	for {
		yyj25++
		if yyhl25 {
			yyb25 = yyj25 > l
		} else {
			yyb25 = r.CheckBreak()
		}
		if yyb25 {
			break
		}
		z.DecSendContainerState(codecSelfer_containerArrayElem1234)
		z.DecStructFieldNotFound(yyj25-1, "")
	}
	z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
}

func (x *TestTypeList) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yym31 := z.EncBinary()
		_ = yym31
		if false {
		} else if z.HasExtensions() && z.EncExt(x) {
		} else {
			yysep32 := !z.EncBinary()
			yy2arr32 := z.EncBasicHandle().StructToArray
			var yyq32 [4]bool
			_, _, _ = yysep32, yyq32, yy2arr32
			const yyr32 bool = false
			yyq32[0] = x.Kind != ""
			yyq32[1] = x.APIVersion != ""
			yyq32[2] = true
			var yynn32 int
			if yyr32 || yy2arr32 {
				r.EncodeArrayStart(4)
			} else {
				yynn32 = 1
				for _, b := range yyq32 {
					if b {
						yynn32++
					}
				}
				r.EncodeMapStart(yynn32)
				yynn32 = 0
			}
			if yyr32 || yy2arr32 {
				z.EncSendContainerState(codecSelfer_containerArrayElem1234)
				if yyq32[0] {
					yym34 := z.EncBinary()
					_ = yym34
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.Kind))
					}
				} else {
					r.EncodeString(codecSelferC_UTF81234, "")
				}
			} else {
				if yyq32[0] {
					z.EncSendContainerState(codecSelfer_containerMapKey1234)
					r.EncodeString(codecSelferC_UTF81234, string("kind"))
					z.EncSendContainerState(codecSelfer_containerMapValue1234)
					yym35 := z.EncBinary()
					_ = yym35
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.Kind))
					}
				}
			}
			if yyr32 || yy2arr32 {
				z.EncSendContainerState(codecSelfer_containerArrayElem1234)
				if yyq32[1] {
					yym37 := z.EncBinary()
					_ = yym37
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.APIVersion))
					}
				} else {
					r.EncodeString(codecSelferC_UTF81234, "")
				}
			} else {
				if yyq32[1] {
					z.EncSendContainerState(codecSelfer_containerMapKey1234)
					r.EncodeString(codecSelferC_UTF81234, string("apiVersion"))
					z.EncSendContainerState(codecSelfer_containerMapValue1234)
					yym38 := z.EncBinary()
					_ = yym38
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.APIVersion))
					}
				}
			}
			if yyr32 || yy2arr32 {
				z.EncSendContainerState(codecSelfer_containerArrayElem1234)
				if yyq32[2] {
					yy40 := &x.ListMeta
					yym41 := z.EncBinary()
					_ = yym41
					if false {
					} else if z.HasExtensions() && z.EncExt(yy40) {
					} else {
						z.EncFallback(yy40)
					}
				} else {
					r.EncodeNil()
				}
			} else {
				if yyq32[2] {
					z.EncSendContainerState(codecSelfer_containerMapKey1234)
					r.EncodeString(codecSelferC_UTF81234, string("metadata"))
					z.EncSendContainerState(codecSelfer_containerMapValue1234)
					yy42 := &x.ListMeta
					yym43 := z.EncBinary()
					_ = yym43
					if false {
					} else if z.HasExtensions() && z.EncExt(yy42) {
					} else {
						z.EncFallback(yy42)
					}
				}
			}
			if yyr32 || yy2arr32 {
				z.EncSendContainerState(codecSelfer_containerArrayElem1234)
				if x.Items == nil {
					r.EncodeNil()
				} else {
					yym45 := z.EncBinary()
					_ = yym45
					if false {
					} else {
						h.encSliceTestType(([]TestType)(x.Items), e)
					}
				}
			} else {
				z.EncSendContainerState(codecSelfer_containerMapKey1234)
				r.EncodeString(codecSelferC_UTF81234, string("items"))
				z.EncSendContainerState(codecSelfer_containerMapValue1234)
				if x.Items == nil {
					r.EncodeNil()
				} else {
					yym46 := z.EncBinary()
					_ = yym46
					if false {
					} else {
						h.encSliceTestType(([]TestType)(x.Items), e)
					}
				}
			}
			if yyr32 || yy2arr32 {
				z.EncSendContainerState(codecSelfer_containerArrayEnd1234)
			} else {
				z.EncSendContainerState(codecSelfer_containerMapEnd1234)
			}
		}
	}
}

func (x *TestTypeList) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yym47 := z.DecBinary()
	_ = yym47
	if false {
	} else if z.HasExtensions() && z.DecExt(x) {
	} else {
		yyct48 := r.ContainerType()
		if yyct48 == codecSelferValueTypeMap1234 {
			yyl48 := r.ReadMapStart()
			if yyl48 == 0 {
				z.DecSendContainerState(codecSelfer_containerMapEnd1234)
			} else {
				x.codecDecodeSelfFromMap(yyl48, d)
			}
		} else if yyct48 == codecSelferValueTypeArray1234 {
			yyl48 := r.ReadArrayStart()
			if yyl48 == 0 {
				z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
			} else {
				x.codecDecodeSelfFromArray(yyl48, d)
			}
		} else {
			panic(codecSelferOnlyMapOrArrayEncodeToStructErr1234)
		}
	}
}

func (x *TestTypeList) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yys49Slc = z.DecScratchBuffer() // default slice to decode into
	_ = yys49Slc
	var yyhl49 bool = l >= 0
	for yyj49 := 0; ; yyj49++ {
		if yyhl49 {
			if yyj49 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecSendContainerState(codecSelfer_containerMapKey1234)
		yys49Slc = r.DecodeBytes(yys49Slc, true, true)
		yys49 := string(yys49Slc)
		z.DecSendContainerState(codecSelfer_containerMapValue1234)
		switch yys49 {
		case "kind":
			if r.TryDecodeAsNil() {
				x.Kind = ""
			} else {
				x.Kind = string(r.DecodeString())
			}
		case "apiVersion":
			if r.TryDecodeAsNil() {
				x.APIVersion = ""
			} else {
				x.APIVersion = string(r.DecodeString())
			}
		case "metadata":
			if r.TryDecodeAsNil() {
				x.ListMeta = pkg1_unversioned.ListMeta{}
			} else {
				yyv52 := &x.ListMeta
				yym53 := z.DecBinary()
				_ = yym53
				if false {
				} else if z.HasExtensions() && z.DecExt(yyv52) {
				} else {
					z.DecFallback(yyv52, false)
				}
			}
		case "items":
			if r.TryDecodeAsNil() {
				x.Items = nil
			} else {
				yyv54 := &x.Items
				yym55 := z.DecBinary()
				_ = yym55
				if false {
				} else {
					h.decSliceTestType((*[]TestType)(yyv54), d)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys49)
		} // end switch yys49
	} // end for yyj49
	z.DecSendContainerState(codecSelfer_containerMapEnd1234)
}

func (x *TestTypeList) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj56 int
	var yyb56 bool
	var yyhl56 bool = l >= 0
	yyj56++
	if yyhl56 {
		yyb56 = yyj56 > l
	} else {
		yyb56 = r.CheckBreak()
	}
	if yyb56 {
		z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
		return
	}
	z.DecSendContainerState(codecSelfer_containerArrayElem1234)
	if r.TryDecodeAsNil() {
		x.Kind = ""
	} else {
		x.Kind = string(r.DecodeString())
	}
	yyj56++
	if yyhl56 {
		yyb56 = yyj56 > l
	} else {
		yyb56 = r.CheckBreak()
	}
	if yyb56 {
		z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
		return
	}
	z.DecSendContainerState(codecSelfer_containerArrayElem1234)
	if r.TryDecodeAsNil() {
		x.APIVersion = ""
	} else {
		x.APIVersion = string(r.DecodeString())
	}
	yyj56++
	if yyhl56 {
		yyb56 = yyj56 > l
	} else {
		yyb56 = r.CheckBreak()
	}
	if yyb56 {
		z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
		return
	}
	z.DecSendContainerState(codecSelfer_containerArrayElem1234)
	if r.TryDecodeAsNil() {
		x.ListMeta = pkg1_unversioned.ListMeta{}
	} else {
		yyv59 := &x.ListMeta
		yym60 := z.DecBinary()
		_ = yym60
		if false {
		} else if z.HasExtensions() && z.DecExt(yyv59) {
		} else {
			z.DecFallback(yyv59, false)
		}
	}
	yyj56++
	if yyhl56 {
		yyb56 = yyj56 > l
	} else {
		yyb56 = r.CheckBreak()
	}
	if yyb56 {
		z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
		return
	}
	z.DecSendContainerState(codecSelfer_containerArrayElem1234)
	if r.TryDecodeAsNil() {
		x.Items = nil
	} else {
		yyv61 := &x.Items
		yym62 := z.DecBinary()
		_ = yym62
		if false {
		} else {
			h.decSliceTestType((*[]TestType)(yyv61), d)
		}
	}
	for {
		yyj56++
		if yyhl56 {
			yyb56 = yyj56 > l
		} else {
			yyb56 = r.CheckBreak()
		}
		if yyb56 {
			break
		}
		z.DecSendContainerState(codecSelfer_containerArrayElem1234)
		z.DecStructFieldNotFound(yyj56-1, "")
	}
	z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
}

func (x *TestTypeStatus) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yym63 := z.EncBinary()
		_ = yym63
		if false {
		} else if z.HasExtensions() && z.EncExt(x) {
		} else {
			yysep64 := !z.EncBinary()
			yy2arr64 := z.EncBasicHandle().StructToArray
			var yyq64 [1]bool
			_, _, _ = yysep64, yyq64, yy2arr64
			const yyr64 bool = false
			var yynn64 int
			if yyr64 || yy2arr64 {
				r.EncodeArrayStart(1)
			} else {
				yynn64 = 1
				for _, b := range yyq64 {
					if b {
						yynn64++
					}
				}
				r.EncodeMapStart(yynn64)
				yynn64 = 0
			}
			if yyr64 || yy2arr64 {
				z.EncSendContainerState(codecSelfer_containerArrayElem1234)
				yym66 := z.EncBinary()
				_ = yym66
				if false {
				} else {
					r.EncodeString(codecSelferC_UTF81234, string(x.Blah))
				}
			} else {
				z.EncSendContainerState(codecSelfer_containerMapKey1234)
				r.EncodeString(codecSelferC_UTF81234, string("Blah"))
				z.EncSendContainerState(codecSelfer_containerMapValue1234)
				yym67 := z.EncBinary()
				_ = yym67
				if false {
				} else {
					r.EncodeString(codecSelferC_UTF81234, string(x.Blah))
				}
			}
			if yyr64 || yy2arr64 {
				z.EncSendContainerState(codecSelfer_containerArrayEnd1234)
			} else {
				z.EncSendContainerState(codecSelfer_containerMapEnd1234)
			}
		}
	}
}

func (x *TestTypeStatus) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yym68 := z.DecBinary()
	_ = yym68
	if false {
	} else if z.HasExtensions() && z.DecExt(x) {
	} else {
		yyct69 := r.ContainerType()
		if yyct69 == codecSelferValueTypeMap1234 {
			yyl69 := r.ReadMapStart()
			if yyl69 == 0 {
				z.DecSendContainerState(codecSelfer_containerMapEnd1234)
			} else {
				x.codecDecodeSelfFromMap(yyl69, d)
			}
		} else if yyct69 == codecSelferValueTypeArray1234 {
			yyl69 := r.ReadArrayStart()
			if yyl69 == 0 {
				z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
			} else {
				x.codecDecodeSelfFromArray(yyl69, d)
			}
		} else {
			panic(codecSelferOnlyMapOrArrayEncodeToStructErr1234)
		}
	}
}

func (x *TestTypeStatus) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yys70Slc = z.DecScratchBuffer() // default slice to decode into
	_ = yys70Slc
	var yyhl70 bool = l >= 0
	for yyj70 := 0; ; yyj70++ {
		if yyhl70 {
			if yyj70 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecSendContainerState(codecSelfer_containerMapKey1234)
		yys70Slc = r.DecodeBytes(yys70Slc, true, true)
		yys70 := string(yys70Slc)
		z.DecSendContainerState(codecSelfer_containerMapValue1234)
		switch yys70 {
		case "Blah":
			if r.TryDecodeAsNil() {
				x.Blah = ""
			} else {
				x.Blah = string(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys70)
		} // end switch yys70
	} // end for yyj70
	z.DecSendContainerState(codecSelfer_containerMapEnd1234)
}

func (x *TestTypeStatus) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj72 int
	var yyb72 bool
	var yyhl72 bool = l >= 0
	yyj72++
	if yyhl72 {
		yyb72 = yyj72 > l
	} else {
		yyb72 = r.CheckBreak()
	}
	if yyb72 {
		z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
		return
	}
	z.DecSendContainerState(codecSelfer_containerArrayElem1234)
	if r.TryDecodeAsNil() {
		x.Blah = ""
	} else {
		x.Blah = string(r.DecodeString())
	}
	for {
		yyj72++
		if yyhl72 {
			yyb72 = yyj72 > l
		} else {
			yyb72 = r.CheckBreak()
		}
		if yyb72 {
			break
		}
		z.DecSendContainerState(codecSelfer_containerArrayElem1234)
		z.DecStructFieldNotFound(yyj72-1, "")
	}
	z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
}

func (x codecSelfer1234) encSliceTestType(v []TestType, e *codec1978.Encoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.EncodeArrayStart(len(v))
	for _, yyv74 := range v {
		z.EncSendContainerState(codecSelfer_containerArrayElem1234)
		yy75 := &yyv74
		yy75.CodecEncodeSelf(e)
	}
	z.EncSendContainerState(codecSelfer_containerArrayEnd1234)
}

func (x codecSelfer1234) decSliceTestType(v *[]TestType, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv76 := *v
	yyh76, yyl76 := z.DecSliceHelperStart()
	var yyc76 bool
	if yyl76 == 0 {
		if yyv76 == nil {
			yyv76 = []TestType{}
			yyc76 = true
		} else if len(yyv76) != 0 {
			yyv76 = yyv76[:0]
			yyc76 = true
		}
	} else if yyl76 > 0 {
		var yyrr76, yyrl76 int
		var yyrt76 bool
		if yyl76 > cap(yyv76) {

			yyrg76 := len(yyv76) > 0
			yyv276 := yyv76
			yyrl76, yyrt76 = z.DecInferLen(yyl76, z.DecBasicHandle().MaxInitLen, 272)
			if yyrt76 {
				if yyrl76 <= cap(yyv76) {
					yyv76 = yyv76[:yyrl76]
				} else {
					yyv76 = make([]TestType, yyrl76)
				}
			} else {
				yyv76 = make([]TestType, yyrl76)
			}
			yyc76 = true
			yyrr76 = len(yyv76)
			if yyrg76 {
				copy(yyv76, yyv276)
			}
		} else if yyl76 != len(yyv76) {
			yyv76 = yyv76[:yyl76]
			yyc76 = true
		}
		yyj76 := 0
		for ; yyj76 < yyrr76; yyj76++ {
			yyh76.ElemContainerState(yyj76)
			if r.TryDecodeAsNil() {
				yyv76[yyj76] = TestType{}
			} else {
				yyv77 := &yyv76[yyj76]
				yyv77.CodecDecodeSelf(d)
			}

		}
		if yyrt76 {
			for ; yyj76 < yyl76; yyj76++ {
				yyv76 = append(yyv76, TestType{})
				yyh76.ElemContainerState(yyj76)
				if r.TryDecodeAsNil() {
					yyv76[yyj76] = TestType{}
				} else {
					yyv78 := &yyv76[yyj76]
					yyv78.CodecDecodeSelf(d)
				}

			}
		}

	} else {
		yyj76 := 0
		for ; !r.CheckBreak(); yyj76++ {

			if yyj76 >= len(yyv76) {
				yyv76 = append(yyv76, TestType{}) // var yyz76 TestType
				yyc76 = true
			}
			yyh76.ElemContainerState(yyj76)
			if yyj76 < len(yyv76) {
				if r.TryDecodeAsNil() {
					yyv76[yyj76] = TestType{}
				} else {
					yyv79 := &yyv76[yyj76]
					yyv79.CodecDecodeSelf(d)
				}

			} else {
				z.DecSwallow()
			}

		}
		if yyj76 < len(yyv76) {
			yyv76 = yyv76[:yyj76]
			yyc76 = true
		} else if yyj76 == 0 && yyv76 == nil {
			yyv76 = []TestType{}
			yyc76 = true
		}
	}
	yyh76.End()
	if yyc76 {
		*v = yyv76
	}
}
